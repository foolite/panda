package panda.dao.sql.expert;

import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

import panda.dao.criteria.Query;
import panda.dao.entity.Entity;
import panda.dao.entity.EntityField;
import panda.dao.sql.JdbcTypes;
import panda.lang.Strings;

public class Db2SqlExpert extends SqlExpert {
	@Override
	public List<String> create(Entity<?> entity) {
		List<String> sqls = new ArrayList<String>();

		StringBuilder sb = new StringBuilder("CREATE TABLE " + entity.getTableName() + "(");
		for (EntityField ef : entity.getFields()) {
			sb.append('\n').append(escapeColumn(ef.getColumn()));
			sb.append(' ').append(evalFieldType(ef));
			if (ef.isNotNull()) {
				sb.append(" NOT NULL");
			}
			if (ef.hasDefaultValue()) {
				sb.append(" DEFAULT '").append(ef.getDefaultValue()).append('\'');
			}
			if (ef.isAutoIncrement()) {
				sb.append(" GENERATED BY DEFAULT AS IDENTITY ");
				if (ef.getStartWith() > 1) {
					sb.append("(START ").append(ef.getStartWith()).append(" INCREMENT BY 1) ");
				}
			}
			sb.append(',');
		}
		// append primary keys
		addPrimaryKeys(sb, entity);

		sb.setCharAt(sb.length() - 1, ')');
		sqls.add(sb.toString());

		addIndexes(sqls, entity);
		addComments(sqls, entity);
		return sqls;
	}

	@Override
	public String dropTable(String tableName) {
		return "DROP TABLE " + escapeTable(tableName);
	}

	@Override
	protected String evalFieldType(EntityField ef) {
		if (Strings.isNotEmpty(ef.getDbType())) {
			return super.evalFieldType(ef);
		}
		
		int jdbcType = JdbcTypes.getType(ef.getJdbcType());
		switch (jdbcType) {
		case Types.BIT:
		case Types.BOOLEAN:
			return "CHAR(1)";
		case Types.TINYINT:
			return JdbcTypes.SMALLINT;
		case Types.FLOAT:
			return "DECFLOAT";
		case Types.BINARY:
		case Types.VARBINARY:
		case Types.LONGVARBINARY:
		case Types.BLOB:
			return JdbcTypes.BLOB;
		case Types.CLOB:
		case Types.LONGVARCHAR:
			return JdbcTypes.CLOB;
		default:
			break;
		}
		return super.evalFieldType(ef);
	}


	/**
	 * @param sql sql
	 * @param query query
	 */
	@Override
	protected void setLimitAndOffset(StringBuilder sql, Query query) {
		if (query.getLimit() > 0) {
			int start = query.getStart() > 0 ? query.getStart() : 0;

			sql.insert(0, "SELECT * FROM (SELECT ROW_NUMBER() OVER() AS RN_, T.* FROM (");
			sql.append(") T WHERE RN_ BETWEEN ").append(start).append(" AND ").append(start + query.getLimit());
		}
	}
}
